<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="theme-color" content="#3b3e43"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no"/><title>[转]JDK1.8的新特性 - 会炒菜的程序圆</title><meta name="description" content="JDK1.8已经发布很久了，在很多企业中都已经在使用。并且Spring5、SpringBoot2.0都推荐使用JDK1.8以上版本。所以我们必须与时俱进，拥抱变化。"/><meta property="og:description" content="JDK1.8已经发布很久了，在很多企业中都已经在使用。并且Spring5、SpringBoot2.0都推荐使用JDK1.8以上版本。所以我们必须与时俱进，拥抱变化。"/>    <meta name="keywords" content="Solo,Java,博客,开源"/><link rel="dns-prefetch" href="https://eighteen20.github.io"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://eighteen20.github.io"><link rel="icon" type="image/png" href="https://static.b3log.org/images/brand/solo-128.png"/><link rel="apple-touch-icon" href="https://static.b3log.org/images/brand/solo-128.png"><link rel="shortcut icon" type="image/x-icon" href="https://static.b3log.org/images/brand/solo-128.png"><meta name="copyright" content="B3log"/><meta http-equiv="Window-target" content="_top"/><meta property="og:locale" content="zh_CN"/><meta property="og:title" content="[转]JDK1.8的新特性 - 会炒菜的程序圆"/><meta property="og:site_name" content="会炒菜的程序圆"/><meta property="og:url"      content="https://eighteen20.github.io/articles/2020/09/28/1601305323746.html?"/><meta property="og:image" content="https://static.b3log.org/images/brand/solo-128.png"/><link rel="search" type="application/opensearchdescription+xml" title="[转]JDK1.8的新特性 - 会炒菜的程序圆" href="/opensearch.xml"><link href="https://eighteen20.github.io/rss.xml" title="RSS" type="application/rss+xml" rel="alternate"/><link rel="manifest" href="https://eighteen20.github.io/manifest.json">        <link rel="canonical" href="https://eighteen20.github.io/articles/2020/09/28/1601305323746.html">        <link rel="stylesheet"
              href="https://eighteen20.github.io/skins/Casper/css/base.css?1601305088232"/>
            <link rel="next" title="Java反射机制那些事" href="https://eighteen20.github.io/articles/2020/09/28/1601305711616.html">
    <script src="https://cdn.jsdelivr.net/npm/vditor@3.5.3/dist/js/icons/ant.js" async="" id="vditorIconScript"></script></head>
<body class="fn__flex-column">
<div id="pjax" class="fn__flex-1">
    
    <header class="header header--article">
        <div class="wrapper header__title">
            <h1 class="header__h1 fn__flex-inline">
                <img src="https://static.b3log.org/images/brand/solo-128.png" alt="会炒菜的程序圆">
                <a href="https://eighteen20.github.io" rel="start" class="header__title">会炒菜的程序圆</a>
            </h1>
            <h2 class="header__h2">要码字，会生活</h2>
        </div>
        <nav class="wrapper header__nav fn__clear">
            <a href="https://eighteen20.github.io" rel="start">
                    会炒菜的程序圆
            </a>



            <div class="fn__right">
    <a href="https://ld246.com/member/liujinmai"
       title="https://ld246.com/member/liujinmai"
       class="user__site"
       target="_blank" rel="noopener nofollow">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path fill="#d23f31" style="fill: var(--color1, #d23f31)" d="M5.787 17.226h17.033l5.954 9.528c0.47 0.752 0.003 1.361-1.042 1.361h-15.141z"></path>
            <path d="M10.74 3.927h17.033c1.045 0 1.512 0.609 1.042 1.361l-5.954 9.528h-19.872l6.379-10.209c0.235-0.376 0.849-0.681 1.372-0.681z"></path>
            <path d="M2.953 17.226h2.839l6.804 10.889h-1.892c-0.523 0-1.137-0.305-1.372-0.681z"></path>
        </svg>
    </a>


                <a rel="alternate" href="https://eighteen20.github.io/rss.xml">
                    RSS
                </a>

            </div>
        </nav>
    </header>
    <div class="article__top">
        <div class="fn__clear">
            <div class="toc fn__none" onclick="$('.post__toc').slideToggle()">目录</div>
            <div class="title fn__pointer" onclick="Util.goTop()">[转]JDK1.8的新特性</div>
<div class="article__share"
     data-title="[转]JDK1.8的新特性"
     data-blogtitle="会炒菜的程序圆"
     data-url="https://eighteen20.github.io/articles/2020/09/28/1601305323746.html"
     data-avatar="https://b3logfile.com/avatar/1601059830254.png?imageView2/1/w/128/h/128/interlace/0/q/100">
    <span class="item" data-type="qqz">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M22.824 13.989l-8.348 6.287s3.351 0.522 8.404 0.461l-0.23-1.040 7.2-6.549c0.132-0.12 0.183-0.312 0.129-0.487s-0.203-0.299-0.377-0.314l-9.492-0.856-3.708-9.213c-0.068-0.169-0.226-0.279-0.401-0.279s-0.333 0.11-0.401 0.279l-3.708 9.213-9.492 0.856c-0.174 0.015-0.323 0.139-0.377 0.314s-0.004 0.366 0.129 0.487l7.2 6.549-2.158 9.742c-0.040 0.178 0.026 0.365 0.168 0.474 0.142 0.107 0.331 0.115 0.481 0.021l8.158-5.165 8.158 5.165c0.070 0.045 0.147 0.066 0.225 0.066 0.090 0 0.18-0.029 0.256-0.086 0.142-0.109 0.208-0.295 0.168-0.474l-1.707-7.704c0.732-0.386 1.538-1.040 1.538-1.040s-3.195 1.638-14.664 0.838l8.312-6.325s-0.327-0.534-10.744-0.914c-0.697-0.026 8.493-1.83 15.281-0.305z"></path>
        </svg>
    </span>
    <span class="item" data-type="wechat">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M9.062 9.203c0-0.859-0.562-1.422-1.422-1.422-0.844 0-1.703 0.562-1.703 1.422 0 0.844 0.859 1.406 1.703 1.406 0.859 0 1.422-0.562 1.422-1.406zM20.672 17.125c0-0.562-0.562-1.125-1.422-1.125-0.562 0-1.125 0.562-1.125 1.125 0 0.578 0.562 1.141 1.125 1.141 0.859 0 1.422-0.562 1.422-1.141zM16.984 9.203c0-0.859-0.562-1.422-1.406-1.422-0.859 0-1.703 0.562-1.703 1.422 0 0.844 0.844 1.406 1.703 1.406 0.844 0 1.406-0.562 1.406-1.406zM26.906 17.125c0-0.562-0.578-1.125-1.422-1.125-0.562 0-1.125 0.562-1.125 1.125 0 0.578 0.562 1.141 1.125 1.141 0.844 0 1.422-0.562 1.422-1.141zM22.75 10.922c-0.359-0.047-0.719-0.063-1.094-0.063-5.375 0-9.625 4.016-9.625 8.953 0 0.828 0.125 1.625 0.359 2.375-0.359 0.031-0.703 0.047-1.063 0.047-1.422 0-2.547-0.281-3.969-0.562l-3.953 1.984 1.125-3.406c-2.828-1.984-4.531-4.547-4.531-7.656 0-5.391 5.094-9.625 11.328-9.625 5.563 0 10.453 3.391 11.422 7.953zM32 19.687c0 2.547-1.688 4.813-3.969 6.516l0.859 2.828-3.109-1.703c-1.141 0.281-2.281 0.578-3.406 0.578-5.391 0-9.625-3.688-9.625-8.219s4.234-8.219 9.625-8.219c5.094 0 9.625 3.688 9.625 8.219z"></path>
        </svg>
    </span>
    <span class="item" data-type="weibo">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M13.444 27.064c-5.3 0.525-9.875-1.875-10.219-5.35-0.344-3.481 3.675-6.719 8.969-7.244 5.3-0.525 9.875 1.875 10.212 5.35 0.35 3.481-3.669 6.725-8.963 7.244zM24.038 15.521c-0.45-0.137-0.762-0.225-0.525-0.819 0.512-1.287 0.563-2.394 0.006-3.188-1.038-1.481-3.881-1.406-7.137-0.037 0 0-1.025 0.444-0.762-0.363 0.5-1.613 0.425-2.956-0.356-3.737-1.769-1.769-6.469 0.069-10.5 4.1-3.013 3.006-4.763 6.212-4.763 8.981 0 5.287 6.787 8.506 13.425 8.506 8.7 0 14.494-5.056 14.494-9.069 0-2.431-2.044-3.806-3.881-4.375z"></path>
            <path d="M29.819 5.833c-2.1-2.331-5.2-3.219-8.063-2.612v0c-0.663 0.144-1.081 0.794-0.938 1.45 0.144 0.662 0.788 1.081 1.45 0.938 2.038-0.431 4.238 0.2 5.731 1.856s1.9 3.913 1.256 5.888v0c-0.206 0.644 0.144 1.331 0.788 1.544 0.644 0.206 1.331-0.144 1.544-0.787v-0.006c0.9-2.762 0.331-5.938-1.769-8.269z"></path>
            <path d="M26.588 8.752c-1.025-1.138-2.538-1.569-3.925-1.269-0.569 0.119-0.931 0.688-0.813 1.256 0.125 0.569 0.688 0.931 1.25 0.806v0c0.681-0.144 1.419 0.069 1.919 0.619 0.5 0.556 0.637 1.313 0.419 1.975v0c-0.175 0.55 0.125 1.15 0.681 1.331 0.556 0.175 1.15-0.125 1.331-0.681 0.438-1.356 0.163-2.906-0.863-4.037z"></path>
            <path d="M13.738 20.771c-0.188 0.319-0.594 0.469-0.912 0.337-0.319-0.125-0.412-0.488-0.231-0.794 0.188-0.306 0.581-0.456 0.894-0.337 0.313 0.113 0.425 0.469 0.25 0.794zM12.044 22.933c-0.512 0.819-1.613 1.175-2.438 0.8-0.813-0.369-1.056-1.319-0.544-2.119 0.506-0.794 1.569-1.15 2.388-0.806 0.831 0.356 1.1 1.3 0.594 2.125zM13.969 17.146c-2.519-0.656-5.369 0.6-6.463 2.819-1.119 2.262-0.037 4.781 2.506 5.606 2.638 0.85 5.75-0.456 6.831-2.894 1.069-2.394-0.262-4.85-2.875-5.531z"></path>
        </svg>
    </span>
    <span class="item" data-type="twitter">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M32.003 6.075c-1.175 0.525-2.444 0.875-3.769 1.031 1.356-0.813 2.394-2.1 2.887-3.631-1.269 0.75-2.675 1.3-4.169 1.594-1.2-1.275-2.906-2.069-4.794-2.069-3.625 0-6.563 2.938-6.563 6.563 0 0.512 0.056 1.012 0.169 1.494-5.456-0.275-10.294-2.888-13.531-6.862-0.563 0.969-0.887 2.1-0.887 3.3 0 2.275 1.156 4.287 2.919 5.463-1.075-0.031-2.087-0.331-2.975-0.819 0 0.025 0 0.056 0 0.081 0 3.181 2.263 5.838 5.269 6.437-0.55 0.15-1.131 0.231-1.731 0.231-0.425 0-0.831-0.044-1.237-0.119 0.838 2.606 3.263 4.506 6.131 4.563-2.25 1.762-5.075 2.813-8.156 2.813-0.531 0-1.050-0.031-1.569-0.094 2.913 1.869 6.362 2.95 10.069 2.95 12.075 0 18.681-10.006 18.681-18.681 0-0.287-0.006-0.569-0.019-0.85 1.281-0.919 2.394-2.075 3.275-3.394z"></path>
        </svg>
    </span>
    <span class="item__qr"></span>
</div>        </div>
        <progress class="article__progress"></progress>
    </div>
    <div class="article">
        <div class="ft__center">
            <div class="item__meta">
                <time>
                    2020-09-28
                </time>
                /
                    <a class="tag" rel="tag"
                       href="https://eighteen20.github.io/tags/java">java</a> &nbsp;
            </div>
            <h2 class="item__title">
                [转]JDK1.8的新特性
            </h2>
        </div>
        <div class="item__cover" style="background-image: url(https://b3logfile.com/bing/20200710.jpg?imageView2/1/w/960/h/540/interlace/1/q/100)"></div>
        <div class="wrapper">
            <section class="item__content item__content--article vditor-reset">
                <p><img src="https://b3logfile.com/bing/20200710.jpg?imageView2/1/w/960/h/540/interlace/1/q/100" alt=""></p>
<p>来源：来源网络，作者不详.</p>
<h2 id="toc_h2_0">1. 前言</h2>
<p>Jdk8这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。在本文中我们将学习以下方面的新特性：</p>
<ul>
<li>[Lambda表达式](#2. Lambda表达式)</li>
<li>[函数式接口](#3. 函数式接口)</li>
<li>[方法引用](#4. 方法引用)</li>
<li>[接口的默认方法和静态方法](#5. 接口的默认方法和静态方法)</li>
<li>[Optional](#6. Optional)</li>
<li>[Streams](#7. Streams)</li>
<li>[并行数组](#8. 并行数组)</li>
</ul>
<h2 id="toc_h2_1">2. Lambda表达式</h2>
<p>函数式编程</p>
<p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。可以使代码变的更加简洁紧凑。</p>
<h3 id="toc_h3_2">2.1 基本语法：</h3>
<pre><code>
(参数列表) -&gt; {代码块}

</code></pre>
<p>需要注意：</p>
<ul>
<li>参数类型可省略，编译器可以自己推断</li>
<li>如果只有一个参数，圆括号可以省略</li>
<li>代码块如果只是一行代码，大括号也可以省略</li>
<li>如果代码块是一行，且是有结果的表达式，<code>return</code>可以省略</li>
</ul>
<p><strong>注意：<strong>事实上，把Lambda表达式可以看做是匿名内部类的一种简写方式。当然，前提是这个匿名内部类对应的必须是接口，而且接口中必须只有一个函数！Lambda表达式就是直接编写函数的：参数列表、代码体、返回值等信息，</strong><code>用函数来代替完整的匿名内部类</code></strong>！</p>
<h3 id="toc_h3_3">2.2 用法示例</h3>
<h5 id="toc_h5_4">示例1：多个参数</h5>
<p>准备一个集合：</p>
<pre><code class="language-java">
// 准备一个集合

List&lt;Integer&gt; list = Arrays.asList(10, 5, 25, -15, 20);

</code></pre>
<p>假设我们要对集合排序，我们先看JDK7的写法，需要通过匿名内部类来构造一个<code>Comparator</code>：</p>
<pre><code class="language-java">
// Jdk1.7写法

Collections.sort(list,new Comparator&lt;Integer&gt;() {

    @Override

    public int compare(Integer o1, Integer o2) {

        return o1 - o2;

    }

});

System.out.println(list);// [-15, 5, 10, 20, 25]

</code></pre>
<p>如果是jdk8，我们可以使用新增的集合API：<code>sort(Comparator c)</code>方法，接收一个比较器，我们用Lambda来代替<code>Comparator</code> 的匿名内部类：</p>
<pre><code class="language-java">
// Jdk1.8写法，参数列表的数据类型可省略：

list.sort((i1,i2) -&gt; { return i1 - i2;});



System.out.println(list);// [-15, 5, 10, 20, 25]

</code></pre>
<p>对比一下<code>Comparator</code>中的<code>compare()</code>方法，你会发现：这里编写的Lambda表达式，恰恰就是<code>compare()</code>方法的简写形式，JDK8会把它编译为匿名内部类。是不是简单多了！</p>
<p>别着急，我们发现这里的代码块只有一行代码，符合前面的省略规则，我们可以简写为：</p>
<pre><code class="language-java">
// Jdk8写法

// 因为代码块是一个有返回值的表达式，可以省略大括号以及return

list.sort((i1,i2) -&gt; i1 - i2);

</code></pre>
<h5 id="toc_h5_5">示例2：单个参数</h5>
<p>还以刚才的集合为例，现在我们想要遍历集合中的元素，并且打印。</p>
<p>先用jdk1.7的方式：</p>
<pre><code class="language-java">
// JDK1.7遍历并打印集合

for (Integer i : list) {

    System.out.println(i);

}

</code></pre>
<p>jdk1.8给集合添加了一个方法：<code>foreach()</code> ，接收一个对元素进行操作的函数：</p>
<pre><code class="language-java">
// JDK1.8遍历并打印集合，因为只有一个参数，所以我们可以省略小括号:

list.forEach(i -&gt; System.out.println(i));

</code></pre>
<h5 id="toc_h5_6">实例3：把Lambda赋值给变量</h5>
<p>Lambda表达式的实质其实还是匿名内部类，所以我们其实可以把Lambda表达式赋值给某个变量。</p>
<pre><code class="language-java">
// 将一个Lambda表达式赋值给某个接口：

Runnable task = () -&gt; {

    // 这里其实是Runnable接口的匿名内部类，我们在编写run方法。

    System.out.println("hello lambda!");

};

new Thread(task).start();

</code></pre>
<p>不过上面的用法很少见，一般都是直接把Lambda作为参数。</p>
<h5 id="toc_h5_7">示例4：隐式final</h5>
<p>Lambda表达式的实质其实还是匿名内部类，而匿名内部类在访问外部局部变量时，要求变量必须声明为<code>final</code>！不过我们在使用Lambda表达式时无需声明<code>final</code>，这并不是说违反了匿名内部类的规则，因为Lambda底层会隐式的把变量设置为<code>final</code>，在后续的操作中，一定不能修改该变量：</p>
<p>正确示范：</p>
<pre><code class="language-java">
// 定义一个局部变量

int num = -1;

Runnable r = () -&gt; {

    // 在Lambda表达式中使用局部变量num，num会被隐式声明为final

    System.out.println(num);

};

new Thread(r).start();// -1

</code></pre>
<p>错误案例：</p>
<pre><code class="language-java">
// 定义一个局部变量

int num = -1;

Runnable r = () -&gt; {

    // 在Lambda表达式中使用局部变量num，num会被隐式声明为final，不能进行任何修改操作

    System.out.println(num++);

};

new Thread(r).start();//报错

</code></pre>
<h2 id="toc_h2_8">3. 函数式接口</h2>
<p>经过前面的学习，相信大家对于Lambda表达式已经有了初步的了解。总结一下：</p>
<ul>
<li>Lambda表达式是接口的匿名内部类的简写形式</li>
<li>接口必须满足：内部只有一个函数</li>
</ul>
<p>其实这样的接口，我们称为函数式接口，我们学过的<code>Runnable</code>、<code>Comparator</code>都是函数式接口的典型代表。但是在实践中，函数接口是非常脆弱的，只要有人在接口里添加多一个方法，那么这个接口就不是函数接口了，就会导致编译失败。Java 8提供了一个特殊的注解<code>@FunctionalInterface</code>来克服上面提到的脆弱性并且显示地表明函数接口。而且jdk8版本中，对很多已经存在的接口都添加了<code>@FunctionalInterface</code>注解，例如<code>Runnable</code>接口：</p>
<p><img src="https://b3logfile.com/file/2020/09/runnable-b19a6dd0.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt=""></p>
<p>另外，Jdk8默认提供了一些函数式接口供我们使用：</p>
<h3 id="toc_h3_9">3.1 Function类型接口</h3>
<pre><code class="language-java">
@FunctionalInterface

public interface Function&lt;T, R&gt; {

    // 接收一个参数T，返回一个结果R

    R apply(T t);

}

</code></pre>
<p>Function代表的是有参数，有返回值的函数。还有很多类似的Function接口：</p>
<p>| 接口名                 | 描述                                            |</p>
<table>
<thead></thead>
<tbody></tbody>
</table>
<p>| <code>BiFunction&lt;T,U,R&gt;</code>    | 接收两个T和U类型的参数，并且返回R类型结果的函数 |</p>
<p>| <code>DoubleFunction&lt;R&gt;</code>    | 接收double类型参数，并且返回R类型结果的函数     |</p>
<p>| <code>IntFunction&lt;R&gt;</code>       | 接收int类型参数，并且返回R类型结果的函数        |</p>
<p>| <code>LongFunction&lt;R&gt;</code>      | 接收long类型参数，并且返回R类型结果的函数       |</p>
<p>| <code>ToDoubleFunction&lt;T&gt;</code>  | 接收T类型参数，并且返回double类型结果           |</p>
<p>| <code>ToIntFunction&lt;T&gt;</code>     | 接收T类型参数，并且返回int类型结果              |</p>
<p>| <code>ToLongFunction&lt;T&gt;</code>    | 接收T类型参数，并且返回long类型结果             |</p>
<p>| <code>DoubleToIntFunction</code>  | 接收double类型参数，返回int类型结果             |</p>
<p>| <code>DoubleToLongFunction</code> | 接收double类型参数，返回long类型结果            |</p>
<p>看出规律了吗？这些都是一类函数接口，在Function基础上衍生出的，要么明确了参数不确定返回结果，要么明确结果不知道参数类型，要么两者都知道。</p>
<h3 id="toc_h3_10">3.2 Consumer系列</h3>
<pre><code class="language-java">
@FunctionalInterface

public interface Consumer&lt;T&gt; {

    // 接收T类型参数，不返回结果

    void accept(T t);

}

</code></pre>
<p>Consumer系列与Function系列一样，有各种衍生接口，这里不一一列出了。不过都具备类似的特征：那就是不返回任何结果。</p>
<h3 id="toc_h3_11">3.3 Predicate系列</h3>
<pre><code class="language-java">
@FunctionalInterface

public interface Predicate&lt;T&gt; {

    // 接收T类型参数，返回boolean类型结果

    boolean test(T t);

}

</code></pre>
<p>Predicate系列参数不固定，但是返回的一定是boolean类型。</p>
<h3 id="toc_h3_12">3.4 Supplier系列</h3>
<pre><code class="language-java">
@FunctionalInterface

public interface Supplier&lt;T&gt; {

    // 无需参数，返回一个T类型结果

    T get();

}

</code></pre>
<p>Supplier系列，英文翻译就是“供应者”，顾名思义：只产出，不收取。所以不接受任何参数，返回T类型结果。</p>
<h2 id="toc_h2_13">4. 方法引用</h2>
<p>方法引用使得开发者可以将已经存在的方法作为变量来传递使用。方法引用可以和Lambda表达式配合使用。</p>
<h3 id="toc_h3_14">4.1 语法：</h3>
<p>总共有四类方法引用：</p>
<p>| 语法                   | 描述                             |</p>
<table>
<thead></thead>
<tbody></tbody>
</table>
<p>| 类名::静态方法名       | 类的静态方法的引用               |</p>
<p>| 类名::非静态方法名     | 类的非静态方法的引用             |</p>
<p>| 实例对象::非静态方法名 | 类的指定实例对象的非静态方法引用 |</p>
<p>| 类名::new              | 类的构造方法引用                 |</p>
<h3 id="toc_h3_15">4.2 示例</h3>
<p>首先我们编写一个集合工具类，提供一个方法：</p>
<pre><code class="language-java">
    public class CollectionUtil{

        /**

         * 利用function将list集合中的每一个元素转换后形成新的集合返回

         * @param list 要转换的源集合

         * @param function 转换元素的方式

         * @param &lt;T&gt; 源集合的元素类型

         * @param &lt;R&gt; 转换后的元素类型

         * @return

         */

        public static &lt;T,R&gt; List&lt;R&gt; convert(List&lt;T&gt; list, Function&lt;T,R&gt; function){

            List&lt;R&gt; result = new ArrayList&lt;&gt;();

            list.forEach(t -&gt; result.add(function.apply(t)));

            return result;

        }

    }

</code></pre>
<p>可以看到这个方法接收两个参数：</p>
<ul>
<li><code>List&lt;T&gt; list</code>：需要进行转换的集合</li>
<li><code>Function&lt;T,R&gt;</code>：函数接口，接收T类型，返回R类型。用这个函数接口对list中的元素T进行转换，变为R类型</li>
</ul>
<p>接下来，我们看具体案例：</p>
<h4 id="toc_h4_16">4.2.1 类的静态方法引用</h4>
<pre><code class="language-java">
List&lt;Integer&gt; list = Arrays.asList(1000, 2000, 3000);

</code></pre>
<p>我们需要把这个集合中的元素转为十六进制保存，需要调用<code>Integer.toHexString()</code>方法：</p>
<pre><code class="language-java">
public static String toHexString(int i) {

    return toUnsignedString0(i, 4);

}

</code></pre>
<p>这个方法接收一个 i 类型，返回一个<code>String</code>类型，可以用来构造一个<code>Function</code>的函数接口：</p>
<p>我们先按照Lambda原始写法，传入的Lambda表达式会被编译为<code>Function</code>接口，接口中通过<code>Integer.toHexString(i)</code>对原来集合的元素进行转换：</p>
<pre><code class="language-java">
// 通过Lambda表达式实现

List&lt;String&gt; hexList = CollectionUtil.convert(list, i -&gt; Integer.toHexString(i));

System.out.println(hexList);// [3e8, 7d0, bb8]

</code></pre>
<p>上面的Lambda表达式代码块中，只有对<code>Integer.toHexString()</code>方法的引用，没有其它代码，因此我们可以直接把方法作为参数传递，由编译器帮我们处理，这就是静态方法引用：</p>
<pre><code class="language-java">
// 类的静态方法引用

List&lt;String&gt; hexList = CollectionUtil.convert(list, Integer::toHexString);

System.out.println(hexList);// [3e8, 7d0, bb8]

</code></pre>
<h4 id="toc_h4_17">4.2.2 类的非静态方法引用</h4>
<p>接下来，我们把刚刚生成的<code>String</code>集合<code>hexList</code>中的元素都变成大写，需要借助于String类的toUpperCase()方法：</p>
<pre><code class="language-java">
public String toUpperCase() {

    return toUpperCase(Locale.getDefault());

}

</code></pre>
<p>这次是非静态方法，不能用类名调用，需要用实例对象，因此与刚刚的实现有一些差别，我们接收集合中的每一个字符串<code>s</code>。但与上面不同然后<code>s</code>不是<code>toUpperCase()</code>的参数，而是调用者：</p>
<pre><code class="language-java">
// 通过Lambda表达式，接收String数据，调用toUpperCase()

List&lt;String&gt; upperList = CollectionUtil.convert(hexList, s -&gt; s.toUpperCase());

System.out.println(upperList);// [3E8, 7D0, BB8]

</code></pre>
<p>因为代码体只有对<code>toUpperCase()</code>的调用，所以可以把方法作为参数引用传递，依然可以简写：</p>
<pre><code class="language-java">
// 类的成员方法

List&lt;String&gt; upperList = CollectionUtil.convert(hexList, String::toUpperCase);

System.out.println(upperList);// [3E8, 7D0, BB8]

</code></pre>
<h4 id="toc_h4_18">4.2.3 指定实例的非静态方法引用</h4>
<p>下面一个需求是这样的，我们先定义一个数字<code>Integer num = 2000</code>，然后用这个数字和集合中的每个数字进行比较，比较的结果放入一个新的集合。比较对象，我们可以用<code>Integer</code>的<code>compareTo</code>方法:</p>
<pre><code class="language-java">
public int compareTo(Integer anotherInteger) {

    return compare(this.value, anotherInteger.value);

}

</code></pre>
<p>先用Lambda实现，</p>
<pre><code class="language-java">
List&lt;Integer&gt; list = Arrays.asList(1000, 2000, 3000);



// 某个对象的成员方法

Integer num = 2000;

List&lt;Integer&gt; compareList = CollectionUtil.convert(list, i -&gt; num.compareTo(i));

System.out.println(compareList);// [1, 0, -1]

</code></pre>
<p>与前面类似，这里Lambda的代码块中，依然只有对<code>num.compareTo(i)</code>的调用，所以可以简写。但是，需要注意的是，这次方法的调用者不是集合的元素，而是一个外部的局部变量<code>num</code>，因此不能使用 <code>Integer::compareTo</code>，因为这样是无法确定方法的调用者。要指定调用者，需要用 <code>对象::方法名</code>的方式：</p>
<pre><code class="language-java">
// 某个对象的成员方法

Integer num = 2000;

List&lt;Integer&gt; compareList = CollectionUtil.convert(list, num::compareTo);

System.out.println(compareList);// [1, 0, -1]

</code></pre>
<h4 id="toc_h4_19">4.2.4 构造函数引用</h4>
<p>最后一个场景：把集合中的数字作为毫秒值，构建出<code>Date</code>对象并放入集合，这里我们就需要用到Date的构造函数：</p>
<pre><code class="language-java">
/**

  * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.

  * @see     java.lang.System#currentTimeMillis()

  */

public Date(long date) {

    fastTime = date;

}

</code></pre>
<p>我们可以接收集合中的每个元素，然后把元素作为<code>Date</code>的构造函数参数：</p>
<pre><code class="language-java">
// 将数值类型集合，转为Date类型

List&lt;Date&gt; dateList = CollectionUtil.convert(list, i -&gt; new Date(i));

// 这里遍历元素后需要打印，因此直接把println作为方法引用传递了

dateList.forEach(System.out::println);

</code></pre>
<p>上面的Lambda表达式实现方式，代码体只有<code>new Date()</code>一行代码，因此也可以采用方法引用进行简写。但问题是，构造函数没有名称，我们只能用<code>new</code>关键字来代替：</p>
<pre><code class="language-java">
// 构造方法

List&lt;Date&gt; dateList = CollectionUtil.convert(list, Date::new);

dateList.forEach(System.out::println);

</code></pre>
<p>注意两点：</p>
<ul>
<li>上面代码中的System.out::println 其实是 指定对象System.out的非静态方法println的引用</li>
<li>如果构造函数有多个，可能无法区分导致传递失败</li>
</ul>
<h2 id="toc_h2_20">5. 接口的默认方法和静态方法</h2>
<p>Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。</p>
<h3 id="toc_h3_21">5.1 默认方法</h3>
<p>默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p>
<p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p>
<pre><code class="language-java">
private interface Defaulable {

    // Interfaces now allow default methods, the implementer may or 

    // may not implement (override) them.

    default String notRequired() { 

        return "Default implementation"; 

    }      

}



private static class DefaultableImpl implements Defaulable {

}



private static class OverridableImpl implements Defaulable {

    @Override

    public String notRequired() {

        return "Overridden implementation";

    }

}

</code></pre>
<p>Defaulable接口使用关键字default定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p>
<h3 id="toc_h3_22">5.2 静态方法</h3>
<p>Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，我们可以直接用接口调用这些静态方法。例子代码如下：</p>
<pre><code class="language-java">
private interface DefaulableFactory {

    // Interfaces now allow static methods

    static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) {

        return supplier.get();

    }

}

</code></pre>
<p>下面的代码片段整合了默认方法和静态方法的使用场景：</p>
<pre><code class="language-java">
public static void main( String[] args ) {

    // 调用接口的静态方法，并且传递DefaultableImpl的构造函数引用来构建对象

    Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new );

    System.out.println( defaulable.notRequired() );

    // 调用接口的静态方法，并且传递OverridableImpl的构造函数引用来构建对象

    defaulable = DefaulableFactory.create( OverridableImpl::new );

    System.out.println( defaulable.notRequired() );

}

</code></pre>
<p>这段代码的输出结果如下：</p>
<pre><code>
Default implementation

Overridden implementation

</code></pre>
<p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给<code>java.util.Collection</code>接口添加新方法，如<code>stream()</code>、<code>parallelStream()</code>、<code>forEach()</code>和<code>removeIf()</code>等等。</p>
<p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考官方文档。</p>
<h2 id="toc_h2_23">6. Optional</h2>
<p>Java应用中最常见的bug就是空值异常。</p>
<p><code>Optional</code>仅仅是一个容器，可以存放T类型的值或者<code>null</code>。它提供了一些有用的接口来避免显式的<code>null</code>检查，可以参考Java 8官方文档了解更多细节。</p>
<p>接下来看一点使用Optional的例子：可能为空的值或者某个类型的值：</p>
<pre><code class="language-java">
Optional&lt; String &gt; fullName = Optional.ofNullable( null );

System.out.println( "Full Name is set? " + fullName.isPresent() );      

System.out.println( "Full Name: " + fullName.orElseGet( () -&gt; "[none]" ) ); 

System.out.println( fullName.map( s -&gt; "Hey " + s + "!" ).orElse( "Hey Stranger!" ) );

</code></pre>
<p>如果<code>Optional</code>实例持有一个非空值，则<code>isPresent()</code>方法返回<code>true</code>，否则返回<code>false</code>；如果<code>Optional</code>实例持有<code>null</code>，<code>orElseGet()</code>方法可以接受一个lambda表达式生成的默认值；<code>map()</code>方法可以将现有的<code>Optional</code>实例的值转换成新的值；<code>orElse()</code>方法与<code>orElseGet()</code>方法类似，但是在持有null的时候返回传入的默认值，而不是通过Lambda来生成。</p>
<p>上述代码的输出结果如下：</p>
<pre><code>
Full Name is set? false

Full Name: [none]

Hey Stranger!

</code></pre>
<p>再看下另一个简单的例子：</p>
<pre><code class="language-java">
Optional&lt; String &gt; firstName = Optional.of( "Tom" );

System.out.println( "First Name is set? " + firstName.isPresent() );      

System.out.println( "First Name: " + firstName.orElseGet( () -&gt; "[none]" ) ); 

System.out.println( firstName.map( s -&gt; "Hey " + s + "!" ).orElse( "Hey Stranger!" ) );

System.out.println();

</code></pre>
<p>这个例子的输出是：</p>
<pre><code>
First Name is set? true

First Name: Tom

Hey Tom!

</code></pre>
<p>如果想了解更多的细节，请参考官方文档。</p>
<h2 id="toc_h2_24">7. Streams</h2>
<p>新增的Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。</p>
<p>Steam API极大得简化了集合操作（后面我们会看到不止是集合），首先看下这个叫Task的类：</p>
<pre><code class="language-java">
public class Streams  {

    private enum Status {

        OPEN, CLOSED

    };



    private static final class Task {

        private final Status status;

        private final Integer points;



        Task( final Status status, final Integer points ) {

            this.status = status;

            this.points = points;

        }



        public Integer getPoints() {

            return points;

        }



        public Status getStatus() {

            return status;

        }



        @Override

        public String toString() {

            return String.format( "[%s, %d]", status, points );

        }

    }

}

</code></pre>
<p>Task类有一个points属性，另外还有两种状态：OPEN或者CLOSED。现在假设有一个task集合：</p>
<pre><code class="language-java">
final Collection&lt; Task &gt; tasks = Arrays.asList(

    new Task( Status.OPEN, 5 ),

    new Task( Status.OPEN, 13 ),

    new Task( Status.CLOSED, 8 ) 

);

</code></pre>
<p>首先看一个问题：在这个task集合中一共有多少个OPEN状态的？计算出它们的points属性和。在Java 8之前，要解决这个问题，则需要使用foreach循环遍历task集合；但是在Java 8中可以利用steams解决：包括一系列元素的列表，并且支持顺序和并行处理。</p>
<pre><code class="language-java">
// Calculate total points of all active tasks using sum()

final long totalPointsOfOpenTasks = tasks

    .stream()

    .filter( task -&gt; task.getStatus() == Status.OPEN )

    .mapToInt( Task::getPoints )

    .sum();



System.out.println( "Total points: " + totalPointsOfOpenTasks );

</code></pre>
<p>运行这个方法的控制台输出是：</p>
<pre><code>
Total points: 18

</code></pre>
<p>这里有很多知识点值得说。首先，<code>tasks</code>集合被转换成<code>steam</code>表示；其次，在<code>steam</code>上的<code>filter</code>操作会过滤掉所有<code>CLOSED</code>的<code>task</code>；第三，<code>mapToInt</code>操作基于<code>tasks</code>集合中的每个<code>task</code>实例的<code>Task::getPoints</code>方法将<code>task</code>流转换成<code>Integer</code>集合；最后，通过<code>sum</code>方法计算总和，得出最后的结果。</p>
<p>在学习下一个例子之前，还需要记住一些steams（点此更多细节）的知识点。Steam之上的操作可分为中间操作和晚期操作。</p>
<p>中间操作会返回一个新的steam——执行一个中间操作（例如filter）并不会执行实际的过滤操作，而是创建一个新的steam，并将原steam中符合条件的元素放入新创建的steam。</p>
<p>晚期操作（例如forEach或者sum），会遍历steam并得出结果或者附带结果；在执行晚期操作之后，steam处理线已经处理完毕，就不能使用了。在几乎所有情况下，晚期操作都是立刻对steam进行遍历。</p>
<p>steam的另一个价值是创造性地支持并行处理（parallel processing）。对于上述的tasks集合，我们可以用下面的代码计算所有task的points之和：</p>
<pre><code class="language-java">
// Calculate total points of all tasks

final double totalPoints = tasks

   .stream()

   .parallel()

   .map( task -&gt; task.getPoints() ) // or map( Task::getPoints ) 

   .reduce( 0, Integer::sum );



System.out.println( "Total points (all tasks): " + totalPoints );

</code></pre>
<p>这里我们使用parallel方法并行处理所有的task，并使用reduce方法计算最终的结果。控制台输出如下：</p>
<pre><code>
Total points（all tasks）: 26.0

</code></pre>
<p>对于一个集合，经常需要根据某些条件对其中的元素分组。利用steam提供的API可以很快完成这类任务，代码如下：</p>
<pre><code class="language-java">
// Group tasks by their status

final Map&lt; Status, List&lt; Task &gt; &gt; map = tasks

    .stream()

    .collect( Collectors.groupingBy( Task::getStatus ) );

System.out.println( map );

</code></pre>
<p>控制台的输出如下：</p>
<pre><code class="language-java">
{CLOSED=[[CLOSED, 8]], OPEN=[[OPEN, 5], [OPEN, 13]]}

</code></pre>
<p>最后一个关于tasks集合的例子问题是：如何计算集合中每个任务的点数在集合中所占的比重，具体处理的代码如下：</p>
<pre><code class="language-java">
// Calculate the weight of each tasks (as percent of total points) 

final Collection&lt; String &gt; result = tasks

    .stream()                                        // Stream&lt; String &gt;

    .mapToInt( Task::getPoints )                     // IntStream

    .asLongStream()                                  // LongStream

    .mapToDouble( points -&gt; points / totalPoints )   // DoubleStream

    .boxed()                                         // Stream&lt; Double &gt;

    .mapToLong( weigth -&gt; ( long )( weigth * 100 ) ) // LongStream

    .mapToObj( percentage -&gt; percentage + "%" )      // Stream&lt; String&gt; 

    .collect( Collectors.toList() );                 // List&lt; String &gt; 



System.out.println( result );

</code></pre>
<p>控制台输出结果如下：</p>
<pre><code>
[19%, 50%, 30%]



</code></pre>
<p>最后，正如之前所说，Steam API不仅可以作用于Java集合，传统的IO操作（从文件或者网络一行一行得读取数据）可以受益于steam处理，这里有一个小例子：</p>
<pre><code class="language-java">
final Path path = new File( filename ).toPath();

try( Stream&lt; String &gt; lines = Files.lines( path, StandardCharsets.UTF_8 ) ) {

    lines.onClose( () -&gt; System.out.println("Done!") ).forEach( System.out::println );

}

</code></pre>
<p>Stream的方法<code>onClose()</code> 返回一个等价的有额外句柄的Stream，当Stream的<code>close()</code>方法被调用的时候这个句柄会被执行。Stream API、Lambda表达式还有接口默认方法和静态方法支持的方法引用，是Java 8对软件开发的现代范式的响应。</p>
<h2 id="toc_h2_25">8. 并行数组</h2>
<p>Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是<code>parallelSort()</code>，可以显著加快多核机器上的数组排序。下面的例子论证了parallexXxx系列的方法：</p>
<pre><code class="language-java">
package com.javacodegeeks.java8.parallel.arrays;



import java.util.Arrays;

import java.util.concurrent.ThreadLocalRandom;



public class ParallelArrays {

    public static void main( String[] args ) {

        long[] arrayOfLong = new long [ 20000 ];      



        Arrays.parallelSetAll( arrayOfLong, 

            index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) );

        Arrays.stream( arrayOfLong ).limit( 10 ).forEach( 

            i -&gt; System.out.print( i + " " ) );

        System.out.println();



        Arrays.parallelSort( arrayOfLong );      

        Arrays.stream( arrayOfLong ).limit( 10 ).forEach( 

            i -&gt; System.out.print( i + " " ) );

        System.out.println();

    }

}

</code></pre>
<p>上述这些代码使用parallelSetAll()方法生成20000个随机数，然后使用parallelSort()方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是：</p>
<pre><code>
Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378 

Sorted: 39 220 263 268 325 607 655 678 723 793

</code></pre>
                    <div>
                        <hr>

标题：[转]JDK1.8的新特性<br>
作者：<a href="https://eighteen20.github.io" target="_blank">liujinmai</a><br>
地址：<a href="https://eighteen20.github.io/articles/2020/09/28/1601305323746.html" target="_blank">https://eighteen20.github.io/articles/2020/09/28/1601305323746.html</a><br>

<!-- 签名档内可使用 HTML、JavaScript -->
<br>
                    </div>
            </section>
        </div>
    </div>
        <div class="post__toc">
<ul class="article__toc">
        <li class="toc__h2">
            <a href="#toc_h2_0">1. 前言</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_1">2. Lambda表达式</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_2">2.1 基本语法：</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_3">2.2 用法示例</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_4">示例1：多个参数</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_5">示例2：单个参数</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_6">实例3：把Lambda赋值给变量</a>
        </li>
        <li class="toc__h5">
            <a href="#toc_h5_7">示例4：隐式final</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_8">3. 函数式接口</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_9">3.1 Function类型接口</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_10">3.2 Consumer系列</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_11">3.3 Predicate系列</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_12">3.4 Supplier系列</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_13">4. 方法引用</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_14">4.1 语法：</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_15">4.2 示例</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_16">4.2.1 类的静态方法引用</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_17">4.2.2 类的非静态方法引用</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_18">4.2.3 指定实例的非静态方法引用</a>
        </li>
        <li class="toc__h4">
            <a href="#toc_h4_19">4.2.4 构造函数引用</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_20">5. 接口的默认方法和静态方法</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_21">5.1 默认方法</a>
        </li>
        <li class="toc__h3">
            <a href="#toc_h3_22">5.2 静态方法</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_23">6. Optional</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_24">7. Streams</a>
        </li>
        <li class="toc__h2">
            <a href="#toc_h2_25">8. 并行数组</a>
        </li>
</ul>        </div>
        <div id="gitalk-container" class="comment__wrapper wrapper" style="margin: 40px auto"></div>
        <div id="b3logsolocomments"></div>
        <div id="vcomment" class="comment__wrapper wrapper" style="margin: 40px auto" data-name="liujinmai" data-postId="1601305323746"></div>
    <div class="article__bottom">
        <div class="wrapper">
            <div class="fn__flex">
                <div class="item" id="randomArticles"></div>
                <div class="item" id="relevantArticles"></div>
            </div>
        </div>
    </div>
    
</div>
<footer class="footer">
    <div class="wrapper fn__clear">
        <div class="fn__left">
            <br>
            &copy; 2020
            <a href="https://eighteen20.github.io">会炒菜的程序圆</a>
            
        </div>
        <div class="fn__right">
            <a href="https://eighteen20.github.io/tags.html" rel="section">
            标签墙
            </a>
            &nbsp;•&nbsp;
            <a href="https://eighteen20.github.io/archives.html">
            存档
            </a>
            &nbsp;•&nbsp;
            <a rel="archive" href="https://eighteen20.github.io/links.html">
            友链
            </a>
            <br>
            4 文章 &nbsp;
            <span data-uvstaturl="https://eighteen20.github.io">0</span> 浏览 &nbsp;
            
        </div>
    </div>
</footer>

<script>
  var Label = {
    speech: true,
    servePath: "https://eighteen20.github.io",
    staticServePath: "https://eighteen20.github.io",
    luteAvailable: false,
    hljsStyle: 'github',
    langLabel: "zh_CN",
    version: "4.3.1",
    staticSite: true,
    showCodeBlockLn: false,
    articleId: "1601305323746",
  }
</script>
<script type="text/javascript"
        src="https://eighteen20.github.io/skins/Casper/js/common.min.js?1601305088232"
        charset="utf-8"></script>
<link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/kanbanniang@0.2.10/index.css"/>
<script async src="https://cdn.jsdelivr.net/npm/kanbanniang@0.2.10/index.js"></script>
<div class="solo-kanbanniang">
    <div class="solo-kanbanniang__tip"></div>
    <canvas id="soloKanbanniang" width="280" height="250"></canvas>
    <div class="solo-kanbanniang__tool">
        <svg id="soloKanbanniangHome" viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M32 18.967l-16-12.42-16 12.42v-5.064l16-12.42 16 12.42zM28 18.516v12h-8v-8h-8v8h-8v-12l12-9z"></path>
        </svg>
        <svg id="soloKanbanniangRSS" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M320.364 768q0 45.728-32 77.728t-77.728 32-77.728-32-32-77.728 32-77.728 77.728-32 77.728 32 32 77.728zM612.94 838.272q1.152 16-9.728 27.424-10.272 12-26.848 12h-77.152q-14.272 0-24.576-9.44t-11.424-23.712q-12.576-130.848-105.44-223.712t-223.712-105.44q-14.272-1.152-23.712-11.424t-9.44-24.576V402.24q0-16.576 12-26.848 9.728-9.728 24.576-9.728h2.848q91.424 7.424 174.848 46.016t148 103.712q65.152 64.576 103.712 148t46.016 174.848z m292.576 1.152q1.152 15.424-10.272 26.848-10.272 11.424-26.272 11.424h-81.728q-14.848 0-25.44-10.016t-11.136-24.288q-6.848-122.848-57.728-233.44t-132.288-192-192-132.288-233.44-58.272q-14.272-0.576-24.288-11.136t-10.016-24.864V109.664q0-16 11.424-26.272 10.272-10.272 25.152-10.272h1.728q149.728 7.424 286.56 68.576t243.136 168q106.848 106.272 168 243.136t68.576 286.56z"></path>
        </svg>
        <svg id="soloKanbanniangChat" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M802.42709 96.163153H219.476155c-84.48109 0-154.896836 71.746044-154.896836 157.840888v393.119449c0 86.072331 70.415746 157.819398 154.896836 157.819399h214.038818V925.470963s22.526039 40.168862 64.767096 5.734608c30.965246-25.819039 126.721123-91.828428 171.775248-123.385145h132.369773c84.502579 0 154.896836-83.21526 154.896836-157.839865V251.125481c0-86.094844-70.394257-154.962328-154.896836-154.962328zM301.144176 518.002714c-39.427988 0-70.416769-31.576159-70.416769-71.746044 0-40.168862 30.988782-71.746044 70.416769-71.746044 39.426965 0 70.393233 31.577183 70.393234 71.746044 0 40.169885-30.966269 71.746044-70.393234 71.746044z m208.411657 0c-39.450501 0-70.415746-31.576159-70.415746-71.746044 0-40.168862 30.965246-71.746044 70.415746-71.746044 39.405475 0 70.394257 31.577183 70.394257 71.746044 0 40.169885-30.988782 71.746044-70.394257 71.746044z m211.203236 0c-39.426965 0-70.416769-31.576159-70.416769-71.746044 0-40.168862 30.988782-71.746044 70.416769-71.746044s70.415746 31.577183 70.415746 71.746044c-0.001023 40.169885-30.988782 71.746044-70.415746 71.746044z"></path>
        </svg>
        <svg id="soloKanbanniangChange" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M936.672 193.216l-226.88-64c-8.704-2.528-18.112-1.12-25.824 3.776-7.68 4.864-12.896 12.736-14.432 21.728C655.712 236.928 595.328 288 512 288c-71.424 0-142.464-103.296-163.776-143.104-7.136-13.28-22.528-19.84-37.024-15.68l-224 64C73.472 197.152 64 209.728 64 224v256a31.93 31.93 0 0 0 11.712 24.736c7.392 6.08 17.152 8.512 26.56 6.624L224 487.04V832c0 52.928 43.072 96 96 96h384c52.928 0 96-43.072 96-96V519.04l121.728 24.352c9.44 1.92 19.2-0.544 26.56-6.624C955.68 530.656 960 521.6 960 512V224c0-14.336-9.536-26.912-23.328-30.784zM672 800H352c-17.664 0-32-14.304-32-32s14.336-32 32-32h320c17.696 0 32 14.304 32 32s-14.304 32-32 32z"></path>
        </svg>
        <svg id="soloKanbanniangPhoto" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M898.048 258.048q23.552-1.024 46.592 9.216t40.96 27.136 28.672 39.424 10.752 46.08l0 390.144q0 24.576-10.752 47.104t-28.672 40.448-40.96 28.16-47.616 10.24l-697.344 0q-24.576 0-48.64-10.24t-42.496-27.648-29.696-40.448-11.264-48.64l0-381.952q0-22.528 10.752-45.568t28.672-41.472 39.936-30.208 44.544-11.776l63.488 0 13.312-83.968q3.072-20.48 18.432-32.768t34.816-12.288l456.704 0q19.456 0 34.304 10.752t16.896 34.304l14.336 83.968 54.272 0zM548.864 712.704q40.96 0 77.824-15.872t63.488-42.496 42.496-62.976 15.872-77.312-15.872-77.312-42.496-62.976-63.488-42.496-77.824-15.872-77.312 15.872-63.488 42.496-43.008 62.976-15.872 77.312 15.872 77.312 43.008 62.976 63.488 42.496 77.312 15.872z"></path>
        </svg>
        <svg id="soloKanbanniangGithub" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M1024 524.8c0 114.346667-32.554667 217.216-97.706667 308.565333-65.066667 91.306667-149.162667 154.538667-252.288 189.610667-11.989333 2.304-20.778667 0.682667-26.325333-4.778667a27.605333 27.605333 0 0 1-8.362667-20.48v-144.213333c0-44.16-11.52-76.501333-34.645333-97.024 25.344-2.730667 48.085333-6.826667 68.309333-12.288a268.629333 268.629333 0 0 0 62.72-26.666667 187.434667 187.434667 0 0 0 53.973334-45.44c14.421333-18.005333 26.197333-41.898667 35.328-71.765333 9.088-29.824 13.653333-64.128 13.653333-102.826667 0-55.125333-17.536-102.058667-52.650667-140.8 16.426667-41.429333 14.677333-87.893333-5.333333-139.392-12.458667-4.096-30.464-1.578667-54.016 7.509334a355.328 355.328 0 0 0-61.312 30.08L640 271.274667a462.336 462.336 0 0 0-128-17.749334c-43.989333 0-86.656 5.930667-128 17.749334a589.824 589.824 0 0 0-28.330667-18.432c-11.776-7.253333-30.336-16.042667-55.68-26.325334-25.344-10.24-44.416-13.312-57.301333-9.216-19.584 51.498667-21.12 97.962667-4.693333 139.434667-35.114667 38.698667-52.650667 85.632-52.650667 140.757333 0 38.698667 4.565333 72.874667 13.653333 102.485334 9.130667 29.610667 20.778667 53.546667 34.986667 71.765333 14.250667 18.218667 32.128 33.493333 53.674667 45.781333 21.546667 12.288 42.453333 21.205333 62.677333 26.666667 20.224 5.461333 43.008 9.557333 68.309333 12.288-17.749333 16.384-28.629333 39.850667-32.64 70.4a130.005333 130.005333 0 0 1-29.994666 10.24c-10.666667 2.261333-23.338667 3.413333-37.973334 3.413333-14.72 0-29.269333-4.906667-43.690666-14.677333-14.464-9.813333-26.794667-24.064-36.992-42.709333a109.226667 109.226667 0 0 0-32.341334-35.541334c-13.141333-9.130667-24.106667-14.592-33.024-16.426666l-13.312-2.048c-9.344 0-15.786667 1.024-19.328 3.072-3.584 2.090667-4.693333 4.693333-3.328 7.893333 1.28 3.157333 3.328 6.4 5.973334 9.557333 2.688 3.2 5.546667 5.930667 8.661333 8.192l4.693333 3.413334c9.770667 4.565333 19.413333 13.226667 29.013334 25.984 9.514667 12.757333 16.512 24.362667 20.992 34.858666l6.656 15.701334c5.76 17.322667 15.530667 31.317333 29.312 42.026666 13.781333 10.666667 28.672 17.536 44.672 20.48 16 2.986667 31.445333 4.565333 46.336 4.821334 14.890667 0.213333 27.221333-0.597333 36.992-2.389334l15.36-2.730666c0 17.28 0.085333 37.546667 0.298666 60.8l0.341334 36.906666a27.050667 27.050667 0 0 1-8.661334 20.48c-5.76 5.461333-14.677333 7.082667-26.666666 4.778667-103.125333-35.072-187.221333-98.261333-252.330667-189.610667C32.554667 742.058667 0 639.146667 0 524.8c0-95.232 22.869333-183.04 68.693333-263.466667A516.266667 516.266667 0 0 1 254.976 70.4C333.44 23.466667 419.114667 0 512 0c92.885333 0 178.56 23.466667 256.981333 70.4a516.266667 516.266667 0 0 1 186.368 190.976C1001.130667 341.802667 1024 429.653333 1024 524.842667z"></path>
        </svg>
        <svg id="soloKanbanniangClose" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M517.572566143763 1018.6748601482986C238.26554897656422 1018.6748601482986 11.897910175114305 792.2714997690043 11.897910175114305 513.0002041796496c0-279.3070171671984 226.36763880144977-505.71037754649296 505.6746559686481-505.71037754649296 279.2712955893538 0 505.6746559686481 226.40336037929444 505.6746559686481 505.71037754649296C1023.2472221124112 792.2714997690043 796.8795833109612 1018.6748601482986 517.572566143763 1018.6748601482986zM754.7281214542927 339.25044954334646c13.752807470184345-13.752807470184345 9.680547595895998-40.186775075214015-9.073280772537204-58.94060344364717l-2.143294670678079-2.1075730928334457c-18.7538283684332-18.7538283684332-45.15207439561819-22.861809820566194-58.90488186580257-9.073280772537204l-168.21291007038468 168.24863164822932-180.42968969324974-180.46541127109438c-13.967136937252159-13.967136937252159-40.72259874288353-9.823433907274534-59.72647815622916 9.216167083915742l-2.143294670678079 2.143294670678079c-19.039600991190277 19.003879413345654-23.111860865478626 45.75934121897699-9.180445506071107 59.655035000539876l180.42968969324974 180.46541127109438-176.07165719620428 176.03593561835962c-13.788529048028984 13.824250625873615-9.716269173740633 40.151053497369375 9.073280772537204 58.94060344364717l2.1075730928334457 2.1075730928334457c18.7538283684332 18.7538283684332 45.15207439561819 22.897531398410823 58.90488186580257 9.073280772537204l176.10737877404887-176.10737877404887 170.39192631890742 170.42764789675192c13.967136937252159 13.931415359407513 40.686877165038865 9.85915548511917 59.690756578384516-9.180445506071107l2.1790162485227142-2.1790162485227142c19.039600991190277-18.968157835501014 23.147582443323273-45.72361964113239 9.180445506071107-59.690756578384516l-170.39192631890742-170.42764789675192L754.7281214542927 339.25044954334646z"></path>
        </svg>
    </div>
</div>


<script type="text/javascript">
    Util.addScript('https://eighteen20.github.io/js/page.min.js?1601305088232', 'soloPageScript')
    var page = new Page({
        "commentContentCannotEmptyLabel": "评论不能为空",
        "oId": "1601305323746",
        "blogHost": "https://eighteen20.github.io",
        "randomArticles1Label": "随机阅读：",
        "externalRelevantArticles1Label": "站外相关阅读："
    });
    $(document).ready(function () {
        page.load();
    page.tips.externalRelevantArticlesDisplayCount = "0";
        page.loadRandomArticles('<h3>随机阅读</h3>');
        page.loadRelevantArticles('1601305323746', '<h3>相关阅读</h3>');
    Skin.initArticle()
    });
</script>

</body>
</html>

<!-- Generated by Latke (https://github.com/88250/latke) in 18ms, 2020/09/28 23:27:35 -->